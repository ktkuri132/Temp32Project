# 驱动框架使用示例

> **注意**：本文档包含所有框架功能的使用示例代码，仅供参考学习，**请勿将其加入编译**。

---

## 目录

1. [框架自动初始化示例](#1-框架自动初始化示例)
2. [日志缓冲区功能示例](#2-日志缓冲区功能示例)

---

## 1. 框架自动初始化示例

### 功能说明

驱动框架自动初始化系统提供在用户代码执行前自动初始化框架的机制，支持4个优先级层次：

- **CORE** - 核心层（日志系统等）- 最先执行
- **PLATFORM** - 平台层（时钟、GPIO等）
- **DEVICE** - 设备层（UART、I2C、SPI等）
- **APPLICATION** - 应用层 - 最后执行

### 三种使用方式

#### 方式1: 自动初始化（推荐，GCC/Clang）

```c
// 在任意一个源文件中添加：
DF_INIT_AUTO_ENABLE();

// 在各个模块中注册初始化函数：
static int my_init(void) { /* ... */ return 0; }
DF_INIT_CORE(my_init, "My Component");

// main函数无需任何修改，框架会自动初始化
int main(void) {
    // 框架已初始化完成
    printf("User code\n");
}
```

#### 方式2: 手动初始化（兼容所有编译器）

```c
// 在各个模块中注册初始化函数（同上）
static int uart_init(void) { /* ... */ return 0; }
DF_INIT_DEVICE(uart_init, "UART");

// 在main函数开始处手动调用：
int main(void) {
    DF_Framework_Init();  // 手动调用
    // ... 用户代码 ...
}
```

#### 方式3: 启动代码集成（深度集成）

```c
// 在启动文件（startup_xxx.s）的Reset_Handler中
// 在跳转到main之前调用DF_Framework_Init()

// 或在SystemInit()函数末尾调用
void SystemInit(void) {
    // ... 系统时钟配置 ...
    DF_Framework_Init();  // 框架初始化
}
```

### 完整示例代码

```c
/**
 * @file df_init_example.c
 * @brief 驱动框架自动初始化使用示例
 * @date 2026-01-01
 */

#include "df_init.h"
#include "df_log.h"
#include <stdio.h>

// ============ 示例1: 核心层初始化（日志系统） ============
static int log_system_init(void)
{
    log_init(LOG_LEVEL_INFO);
    printf("Log system initialized\n");
    return 0;
}
// 注册为核心层初始化（优先级最高）
DF_INIT_CORE(log_system_init, "Log System");

// ============ 示例2: 平台层初始化（时钟、GPIO） ============
static int clock_init(void)
{
    printf("Clock system initialized\n");
    // 实际项目中这里配置系统时钟
    return 0;
}
DF_INIT_PLATFORM(clock_init, "Clock System");

static int gpio_init(void)
{
    printf("GPIO initialized\n");
    // 实际项目中这里初始化GPIO
    return 0;
}
DF_INIT_PLATFORM(gpio_init, "GPIO");

// ============ 示例3: 设备层初始化 ============
static int uart_init(void)
{
    printf("UART initialized\n");
    return 0;
}
DF_INIT_DEVICE(uart_init, "UART");

static int i2c_init(void)
{
    printf("I2C initialized\n");
    return 0;
}
DF_INIT_DEVICE(i2c_init, "I2C");

static int spi_init(void)
{
    printf("SPI initialized\n");
    return 0;
}
DF_INIT_DEVICE(spi_init, "SPI");

// ============ 示例4: 应用层初始化 ============
static int app_config_init(void)
{
    printf("Application config loaded\n");
    return 0;
}
DF_INIT_APPLICATION(app_config_init, "App Config");

// ============ 示例5: 条件初始化（失败示例） ============
static int optional_device_init(void)
{
    printf("Optional device check...\n");
    // 模拟设备不存在
    return -1; // 返回非0表示失败
}
DF_INIT_DEVICE(optional_device_init, "Optional Device");

// ============ 方式1: 自动初始化（GCC/Clang） ============
// 在某个文件中启用自动初始化
#if defined(__GNUC__) || defined(__clang__)
DF_INIT_AUTO_ENABLE(); // 这会在main之前自动调用DF_Framework_Init()
#endif

// ============ 方式3: 分级初始化（高级用法） ============
void advanced_init_example(void)
{
    // 仅初始化核心层
    DF_Init_Level(DF_INIT_LEVEL_CORE);

    // ... 做一些事情 ...

    // 初始化平台层
    DF_Init_Level(DF_INIT_LEVEL_PLATFORM);

    // ... 再做一些事情 ...

    // 初始化设备层
    DF_Init_Level(DF_INIT_LEVEL_DEVICE);

    // 最后初始化应用层
    DF_Init_Level(DF_INIT_LEVEL_APPLICATION);
}

// ============ 测试主函数 ============
int main(void)
{
    printf("\n========== DF Init Example ==========\n\n");

#if !defined(__GNUC__) && !defined(__clang__)
    // 如果不是GCC/Clang，需要手动调用
    printf("Manual initialization (non-GCC compiler)\n");
    DF_Framework_Init();
#else
    // GCC/Clang会自动调用，这里只是检查
    if (DF_Is_Initialized())
    {
        printf("Framework auto-initialized before main!\n\n");
    }
    else
    {
        printf("Auto-init not enabled, calling manually...\n");
        DF_Framework_Init();
    }
#endif

    printf("\n========== User Code Start ==========\n");
    printf("Main application running...\n");

    return 0;
}
```

### 预期输出

```
╔════════════════════════════════════════╗
║  Driver Framework Initialization      ║
╚════════════════════════════════════════╝
[DF_INIT] Level 0 (CORE):
[DF_INIT] Log System...
[DF_INIT]   → 1 items initialized
[DF_INIT] Level 1 (PLATFORM):
[DF_INIT] Clock System...
[DF_INIT] GPIO...
[DF_INIT]   → 2 items initialized
[DF_INIT] Level 2 (DEVICE):
[DF_INIT] UART...
[DF_INIT] I2C...
[DF_INIT] SPI...
[DF_INIT] Optional Device...
[DF_INIT] Optional Device failed (ret=-1)
[DF_INIT]   → 3 items initialized
[DF_INIT] Level 3 (APPLICATION):
[DF_INIT] App Config...
[DF_INIT]   → 1 items initialized
════════════════════════════════════════
[DF_INIT] Total 7 components initialized
════════════════════════════════════════

========== User Code Start ==========
Main application running...
```

### 链接器脚本配置（GCC）

使用 GCC 自动初始化时，需在 `.ld` 文件的 `.rodata` 段中添加：

```ld
.rodata :
{
  /* ... 其他rodata ... */

  /* 驱动框架初始化段 */
  . = ALIGN(4);
  __start_df_init_0 = .;
  KEEP(*(.df_init.0))
  __stop_df_init_0 = .;

  __start_df_init_1 = .;
  KEEP(*(.df_init.1))
  __stop_df_init_1 = .;

  __start_df_init_2 = .;
  KEEP(*(.df_init.2))
  __stop_df_init_2 = .;

  __start_df_init_3 = .;
  KEEP(*(.df_init.3))
  __stop_df_init_3 = .;
} > FLASH
```

### 实际项目中的应用

#### 示例：日志系统自动初始化

在 `df_log.c` 中：

```c
#include "df_init.h"

static int log_auto_init(void)
{
    log_init(LOG_LEVEL_INFO);
    log_buffer_init(2048);
    log_set_buffer_mode(LOG_BUFFER_MODE_BUFFERED);
    return 0;
}
DF_INIT_CORE(log_auto_init, "Log System");
```

#### 示例：I2C总线自动初始化

在 `df_iic.c` 中：

```c
#include "df_init.h"

static int i2c_bus_init(void)
{
    // I2C硬件初始化代码
    I2C_HardwareInit();
    return 0;
}
DF_INIT_DEVICE(i2c_bus_init, "I2C Bus");
```

#### 示例：应用配置加载

在 `app_config.c` 中：

```c
#include "df_init.h"

static int app_config_load(void)
{
    // 从EEPROM或Flash加载配置
    load_config_from_storage();
    return 0;
}
DF_INIT_APPLICATION(app_config_load, "Application Config");
```

---

## 2. 日志缓冲区功能示例

### 功能说明

日志缓冲区功能用于在输出设备（如UART）未就绪时缓存日志，待设备就绪后统一输出。这在嵌入式系统启动阶段特别有用。

**核心功能：**
- 环形缓冲区 - 动态分配，可配置大小
- 模式切换 - `LOG_BUFFER_MODE_DIRECT` / `BUFFERED`
- 溢出策略 - 覆盖旧数据或丢弃新数据
- 缓冲区监控 - 查看使用量、是否满
- 刷新输出 - `log_flush()` 输出所有缓冲日志

### 典型使用流程

```c
// 1. 启动时（输出设备未就绪）
log_init(LOG_LEVEL_INFO);
log_buffer_init(2048);  // 分配2KB缓冲区
log_set_buffer_mode(LOG_BUFFER_MODE_BUFFERED);  // 启用缓冲模式

// 2. 早期日志（存入缓冲区）
LOGI("System boot started\n");
LOGI("Clock configured\n");
LOGI("GPIO initialized\n");

// 3. 设备就绪后
uart_init();
log_set_output(uart_send);  // 设置输出函数
log_flush();  // 输出所有缓冲的日志

// 4. 切换到实时输出
log_set_buffer_mode(LOG_BUFFER_MODE_DIRECT);
LOGI("System ready\n");  // 实时输出
```

### 完整示例代码

```c
/**
 * @file df_log_buffer_example.c
 * @brief 日志缓冲区功能使用示例
 * @date 2026-01-01
 */

#include "df_log.h"
#include <stdio.h>

// ============ 模拟硬件外设状态 ============
static bool uart_ready = false;  // 模拟串口是否就绪

// 模拟串口初始化（延迟100ms）
void uart_init_delayed(void)
{
    // 在实际系统中，这里会进行串口初始化
    // 模拟初始化延迟
    uart_ready = true;
}

// 自定义输出函数（通过串口）
void uart_output(const char *str)
{
    if (uart_ready) {
        printf("UART: %s", str);
    }
}

// ============ 示例1: 基本缓冲功能 ============
void example1_basic_buffer(void)
{
    printf("\n========== Example 1: Basic Buffer ==========\n");

    // 1. 初始化日志系统（缓冲模式）
    log_init(LOG_LEVEL_INFO);
    log_buffer_init(512);  // 512字节缓冲区
    log_set_buffer_mode(LOG_BUFFER_MODE_BUFFERED);  // 启用缓冲模式

    // 2. 此时串口未就绪，日志存入缓冲区
    printf("Phase 1: UART not ready, logs buffered\n");
    LOGI("System initialization started\n");
    LOGI("Clock configured\n");
    LOGI("GPIO initialized\n");
    LOGD("Debug: Buffer usage = %zu bytes\n", log_buffer_get_usage());

    printf("  -> Logs buffered, buffer usage: %zu bytes\n", log_buffer_get_usage());

    // 3. 串口就绪后，设置输出函数并刷新缓冲区
    printf("\nPhase 2: UART ready, flushing buffer\n");
    uart_init_delayed();
    log_set_output(uart_output);

    int flushed = log_flush();  // 输出缓冲的日志
    printf("  -> Flushed %d bytes from buffer\n", flushed);

    // 4. 切换到直接输出模式
    log_set_buffer_mode(LOG_BUFFER_MODE_DIRECT);
    LOGI("Now in direct output mode\n");
}

// ============ 示例2: 溢出策略 ============
void example2_overflow_policy(void)
{
    printf("\n\n========== Example 2: Overflow Policy ==========\n");

    log_init(LOG_LEVEL_INFO);
    log_buffer_init(128);  // 小缓冲区（128字节）
    log_set_buffer_mode(LOG_BUFFER_MODE_BUFFERED);

    // 测试覆盖模式（默认）
    printf("Test 1: Overwrite mode (default)\n");
    log_set_overflow_policy(LOG_OVERFLOW_OVERWRITE);

    for (int i = 0; i < 10; i++) {
        LOGI("Message %d - This is a test message\n", i);
    }

    printf("  Buffer full: %s\n", log_buffer_is_full() ? "YES" : "NO");
    printf("  Buffer usage: %zu/%zu bytes\n",
           log_buffer_get_usage(), 128);

    printf("  Flushing buffer (old messages may be overwritten):\n");
    log_flush();

    // 测试丢弃模式
    printf("\nTest 2: Discard mode\n");
    log_buffer_clear();
    log_set_overflow_policy(LOG_OVERFLOW_DISCARD);

    for (int i = 0; i < 10; i++) {
        LOGI("Message %d - This is a test message\n", i);
    }

    printf("  Buffer usage: %zu bytes (excess discarded)\n",
           log_buffer_get_usage());
    log_flush();
}

// ============ 示例3: 启动阶段完整流程 ============
void example3_bootup_sequence(void)
{
    printf("\n\n========== Example 3: Bootup Sequence ==========\n");

    // ===== 阶段1: 系统启动，硬件未就绪 =====
    printf("\n[STAGE 1] System startup (hardware not ready)\n");
    log_init(LOG_LEVEL_DEBUG);
    log_buffer_init(1024);
    log_set_buffer_mode(LOG_BUFFER_MODE_BUFFERED);  // 缓冲模式

    // 这些日志会被缓冲
    LOGI("=== System Boot ===\n");
    LOGD("CPU: Cortex-M4 @ 168MHz\n");
    LOGD("Flash: 512KB\n");
    LOGD("RAM: 128KB\n");
    LOGI("Clock system initialized\n");
    LOGI("Power management initialized\n");

    printf("  Buffer: %zu bytes used\n", log_buffer_get_usage());

    // ===== 阶段2: 外设初始化 =====
    printf("\n[STAGE 2] Peripheral initialization\n");
    LOGI("Initializing GPIO...\n");
    LOGI("Initializing UART...\n");

    // 模拟UART初始化完成
    uart_ready = true;
    log_set_output(uart_output);

    printf("  Buffer: %zu bytes used\n", log_buffer_get_usage());

    // ===== 阶段3: 输出缓冲的日志 =====
    printf("\n[STAGE 3] UART ready, flushing boot logs\n");
    int flushed = log_flush();
    printf("  -> Flushed %d bytes\n", flushed);

    // ===== 阶段4: 切换到实时输出 =====
    printf("\n[STAGE 4] Switch to real-time logging\n");
    log_set_buffer_mode(LOG_BUFFER_MODE_DIRECT);

    LOGI("System ready\n");
    LOGI("Entering main loop\n");
}

// ============ 示例4: 动态切换模式 ============
void example4_dynamic_switch(void)
{
    printf("\n\n========== Example 4: Dynamic Mode Switch ==========\n");

    log_init(LOG_LEVEL_INFO);
    log_buffer_init(512);
    uart_ready = true;
    log_set_output(uart_output);

    // 正常运行中
    log_set_buffer_mode(LOG_BUFFER_MODE_DIRECT);
    LOGI("Normal operation...\n");

    // 遇到关键操作，临时启用缓冲
    printf("\n[Critical operation] Buffering logs...\n");
    log_set_buffer_mode(LOG_BUFFER_MODE_BUFFERED);

    LOGI("Critical operation started\n");
    LOGD("Step 1 completed\n");
    LOGD("Step 2 completed\n");
    LOGI("Critical operation finished\n");

    printf("  Buffer: %zu bytes\n", log_buffer_get_usage());

    // 操作完成，输出缓冲日志
    printf("\n[Critical operation done] Flushing logs...\n");
    log_flush();

    // 恢复直接输出
    log_set_buffer_mode(LOG_BUFFER_MODE_DIRECT);
    LOGI("Back to normal operation\n");
}

// ============ 示例5: 缓冲区监控 ============
void example5_buffer_monitoring(void)
{
    printf("\n\n========== Example 5: Buffer Monitoring ==========\n");

    log_init(LOG_LEVEL_DEBUG);
    log_buffer_init(256);  // 小缓冲区用于演示
    log_set_buffer_mode(LOG_BUFFER_MODE_BUFFERED);

    printf("Buffer size: 256 bytes\n\n");

    for (int i = 1; i <= 5; i++) {
        LOGI("Log message %d\n", i);

        size_t usage = log_buffer_get_usage();
        printf("  [%d] Buffer: %zu bytes (%.1f%% full) %s\n",
               i, usage, (usage * 100.0) / 256,
               log_buffer_is_full() ? "[FULL]" : "");

        // 当缓冲区接近满时刷新
        if (usage > 200) {
            printf("  -> Buffer nearly full, flushing...\n");
            log_set_output(uart_output);
            uart_ready = true;
            log_flush();
            printf("  -> Buffer cleared\n");
        }
    }
}

// ============ 主函数 ============
int main(void)
{
    printf("╔════════════════════════════════════════╗\n");
    printf("║   Log Buffer System Examples          ║\n");
    printf("╚════════════════════════════════════════╝\n");

    example1_basic_buffer();
    example2_overflow_policy();
    example3_bootup_sequence();
    example4_dynamic_switch();
    example5_buffer_monitoring();

    printf("\n\n========== All Examples Complete ==========\n");

    return 0;
}
```

### 缓冲区大小建议

根据系统规模选择合适的缓冲区大小：

- **小型系统**：512 - 1024 字节
- **中型系统**：2048 - 4096 字节
- **大型系统**：8192+ 字节

### API 参考

| 函数 | 功能 | 参数 |
|------|------|------|
| `log_buffer_init(size)` | 初始化缓冲区 | size: 缓冲区大小（字节） |
| `log_set_buffer_mode(mode)` | 设置缓冲模式 | `LOG_BUFFER_MODE_DIRECT` / `BUFFERED` |
| `log_set_overflow_policy(policy)` | 设置溢出策略 | `LOG_OVERFLOW_OVERWRITE` / `DISCARD` |
| `log_flush()` | 刷新缓冲区 | 返回输出的字节数 |
| `log_buffer_get_usage()` | 获取缓冲区使用量 | 返回已用字节数 |
| `log_buffer_is_full()` | 检查是否满 | 返回 true/false |
| `log_buffer_clear()` | 清空缓冲区 | - |

### 注意事项

1. **内存分配**：`log_buffer_init()` 使用 `malloc()` 动态分配内存，确保堆空间足够
2. **线程安全**：当前实现不是线程安全的，RTOS环境下需要添加互斥锁保护
3. **溢出处理**：
   - `OVERWRITE` 模式：新日志覆盖最旧的日志（适合保留最新信息）
   - `DISCARD` 模式：丢弃新日志（适合保留完整的早期启动日志）
4. **性能考虑**：频繁刷新会影响性能，建议在关键时刻刷新

---

## 完整功能列表

### 框架初始化系统（df_init）

- ✅ 4级优先级自动初始化
- ✅ GCC/Clang 自动初始化支持（constructor）
- ✅ 手动初始化模式（兼容所有编译器）
- ✅ 分级初始化能力
- ✅ 初始化状态查询
- ✅ 初始化结果统计

### 日志系统（df_log）

- ✅ 5个日志级别（ERROR/WARN/INFO/DEBUG/VERBOSE）
- ✅ 彩色输出支持
- ✅ 时间戳功能
- ✅ 环形缓冲区
- ✅ 两种输出模式（直接/缓冲）
- ✅ 两种溢出策略（覆盖/丢弃）
- ✅ 缓冲区监控
- ✅ 自定义输出函数

### 设备管理（dev_frame）

- ✅ 统一设备模型
- ✅ 10种错误码
- ✅ 6种设备状态
- ✅ 设备生命周期管理（open/close/enable/disable/ioctl）
- ✅ 引用计数
- ✅ 私有数据支持

---

## 快速开始

### 步骤1: 配置链接器脚本（GCC用户）

在 `.ld` 文件中添加初始化段（参考上文）

### 步骤2: 启用框架自动初始化

在一个源文件（如 `main.c`）中添加：

```c
#include "df_init.h"

DF_INIT_AUTO_ENABLE();  // GCC/Clang用户
```

或在 `main()` 开头手动调用：

```c
int main(void) {
    DF_Framework_Init();  // 手动初始化
    // ... 用户代码 ...
}
```

### 步骤3: 在各模块注册初始化函数

```c
// df_log.c
static int log_init_auto(void) {
    log_init(LOG_LEVEL_INFO);
    log_buffer_init(2048);
    return 0;
}
DF_INIT_CORE(log_init_auto, "Log System");

// df_iic.c
static int i2c_init_auto(void) {
    // I2C初始化代码
    return 0;
}
DF_INIT_DEVICE(i2c_init_auto, "I2C Bus");
```

### 步骤4: 编译运行

框架会自动完成所有初始化，用户代码无需关心初始化顺序！

---

## 相关文件

- **头文件**：
  - [df_init.h](df_init.h) - 框架初始化系统
  - [df_log.h](df_log.h) - 日志系统
  - [dev_frame.h](dev_frame.h) - 设备管理框架

- **实现文件**：
  - [df_init.c](df_init.c) - 框架初始化实现
  - [df_log.c](df_log.c) - 日志系统实现
  - [dev_frame.c](dev_frame.c) - 设备管理实现

- **文档**：
  - [OPTIMIZATION_GUIDE.md](OPTIMIZATION_GUIDE.md) - 优化指南

---

## 常见问题

### Q1: 为什么自动初始化不工作？

**A:** 检查以下几点：
1. 确认使用 GCC/Clang 编译器
2. 链接器脚本中添加了 `.df_init` 段
3. 在某个源文件中调用了 `DF_INIT_AUTO_ENABLE()`

### Q2: Keil/IAR 如何使用？

**A:** Keil/IAR不支持 `constructor` 属性，请使用**手动初始化方式2**，在 `main()` 开头调用 `DF_Framework_Init()`。

### Q3: 如何调试初始化顺序？

**A:** 框架会输出详细的初始化日志，显示每个级别初始化了哪些组件以及是否成功。

### Q4: 日志缓冲区满了怎么办？

**A:**
- 增加缓冲区大小
- 及时调用 `log_flush()` 刷新
- 使用 `OVERWRITE` 模式保留最新日志
- 降低日志级别减少输出

### Q5: 如何在RTOS中使用？

**A:** 需要添加互斥锁保护：
```c
// 在日志函数中添加
xSemaphoreTake(log_mutex, portMAX_DELAY);
// ... 日志操作 ...
xSemaphoreGive(log_mutex);
```

---

**最后更新时间**：2026-01-01
**维护者**：ktkuri
