# 框架分散自动初始化使用说明

## 概述

驱动框架现已支持分散自动初始化机制，各个框架模块可以将自己的初始化函数注册到指定的初始化段中，在程序启动时自动按优先级顺序执行。

## 设计特点

### 1. 分散注册
每个框架模块在自己的源文件中定义初始化函数，并使用 `DF_INIT_EXPORT` 宏注册到初始化段，无需在主函数中手动调用。

### 2. 优先级控制
通过6个初始化级别，确保各模块按正确的顺序初始化：

```c
DF_INIT_LEVEL_BOARD      = 0,  // 板级初始化（最先执行，如时钟、GPIO）
DF_INIT_LEVEL_PREV       = 1,  // 前置初始化（基础设施，如日志、设备框架）
DF_INIT_LEVEL_DEVICE     = 2,  // 设备初始化（各类设备驱动）
DF_INIT_LEVEL_COMPONENT  = 3,  // 组件初始化（显示、通信等）
DF_INIT_LEVEL_ENV        = 4,  // 环境初始化（文件系统、网络栈等）
DF_INIT_LEVEL_APP        = 5   // 应用初始化（用户应用逻辑）
```

### 3. 自动执行
在 `main()` 函数执行前（GCC）或执行初期自动调用 `df_framework_init()`，完成所有注册的初始化。

## 已集成的框架模块

| 模块名称 | 初始化级别 | 初始化函数 | 功能说明 |
|---------|-----------|-----------|---------|
| **日志系统** | BOARD | `df_log_auto_init` | 最先初始化，为其他模块提供日志输出 |
| **设备框架** | PREV | `df_device_frame_auto_init` | 初始化设备管理框架 |
| **中断管理** | PREV | `df_irq_auto_init` | 初始化中断处理框架 |
| **I2C框架** | DEVICE | `df_iic_auto_init` | 初始化I2C通信框架 |
| **显示框架** | COMPONENT | `df_display_auto_init` | 初始化显示管理框架 |

## 如何为新模块添加自动初始化

### 步骤1：包含头文件
在模块的 `.c` 文件中包含初始化头文件：

```c
#include "df_init.h"
```

### 步骤2：定义初始化函数
定义一个静态初始化函数（建议使用 `static` 避免命名冲突）：

```c
/**
 * @brief 模块自动初始化函数
 * @return 0表示成功，负数表示失败
 */
static int df_my_module_auto_init(void)
{
    // 执行模块初始化逻辑
    my_module_init();

    // 可以使用日志系统（如果在BOARD级别之后）
    LOG_I("MODULE", "My module initialized\n");

    return 0;
}
```

### 步骤3：注册到初始化段
使用 `DF_INIT_EXPORT` 宏将函数注册到合适的初始化级别：

```c
// 注册到设备级别
DF_INIT_EXPORT(df_my_module_auto_init, DF_INIT_LEVEL_DEVICE);
```

### 完整示例

```c
// my_module.c
#include "my_module.h"
#include "df_init.h"
#include "df_log.h"

// 模块私有数据
static bool module_initialized = false;

// 模块初始化实现
static void my_module_init(void)
{
    // 配置硬件
    // 初始化数据结构
    module_initialized = true;
}

// 自动初始化函数
static int df_my_module_auto_init(void)
{
    my_module_init();
    LOG_I("MY_MODULE", "Module initialized successfully\n");
    return 0;
}

// 注册到初始化段（根据模块类型选择级别）
DF_INIT_EXPORT(df_my_module_auto_init, DF_INIT_LEVEL_DEVICE);

// 模块的其他API实现...
```

## 初始化级别选择指南

### BOARD 级别
- **适用场景**：系统最底层的硬件初始化
- **示例**：系统时钟、GPIO端口配置、看门狗、日志系统
- **注意**：此级别不应依赖其他框架模块

### PREV 级别
- **适用场景**：基础设施和框架服务
- **示例**：设备管理框架、内存管理、中断管理
- **注意**：可以使用日志系统

### DEVICE 级别
- **适用场景**：各类硬件设备驱动
- **示例**：UART、SPI、I2C、ADC、定时器驱动
- **注意**：可以使用设备框架和日志系统

### COMPONENT 级别
- **适用场景**：基于设备的功能组件
- **示例**：显示管理、传感器管理、电机控制
- **注意**：可以使用所有设备驱动

### ENV 级别
- **适用场景**：环境和系统服务
- **示例**：文件系统、网络协议栈、Shell
- **注意**：可以使用所有组件和设备

### APP 级别
- **适用场景**：应用层逻辑
- **示例**：用户应用任务、业务逻辑模块
- **注意**：可以使用所有框架功能

## 测试和调试

### 查看初始化日志
框架初始化时会输出每个模块的初始化日志：

```
[I] LOG: Log system initialized
[I] DEV: Device framework initialized
[I] IRQ: Interrupt framework initialized
[I] IIC: I2C framework initialized
[I] DISPLAY: Display framework initialized
```

### 检查初始化状态
在主函数中可以查询初始化状态：

```c
int main(void)
{
    // 框架已自动初始化

    if (df_is_initialized()) {
        printf("Framework initialized successfully\n");
    }

    // 开始应用逻辑
    while(1) {
        // ...
    }
}
```

### 获取初始化函数数量
`df_framework_init()` 返回成功初始化的函数数量：

```c
int count = df_framework_init();
printf("Initialized %d modules\n", count);
```

## 测试程序

项目中包含了完整的测试程序 `app/test_auto_init.c`，演示了如何：
1. 注册多个不同级别的初始化函数
2. 验证初始化顺序
3. 使用已初始化的框架功能（如日志系统）

编译并运行测试程序即可查看完整的初始化过程。

## 注意事项

### 1. 初始化函数设计原则
- 保持简单快速，避免耗时操作
- 返回 0 表示成功，负数表示失败
- 使用 `static` 避免全局命名污染
- 添加详细的注释说明

### 2. 依赖关系
- 高级别的初始化函数可以使用低级别模块的功能
- 不要在低级别中依赖高级别的功能
- BOARD 级别尽量不依赖其他模块

### 3. 错误处理
- 初始化失败应返回负数错误码
- 使用日志记录初始化失败的原因
- 关键模块初始化失败应该停止系统运行

### 4. 编译器支持
- GCC/Clang：使用 `constructor` 属性自动调用
- Keil MDK：使用 `$Sub$$main` 机制自动调用
- IAR：需要在 `main()` 开头手动调用 `df_framework_init()`

## 示例：完整的模块初始化流程

```c
// ========== 文件：my_sensor.c ==========

#include "my_sensor.h"
#include "df_init.h"
#include "df_log.h"
#include "df_iic.h"  // 依赖I2C框架

// 传感器私有数据
typedef struct {
    SIAS *i2c_dev;
    bool initialized;
} sensor_t;

static sensor_t g_sensor = {0};

// 传感器硬件初始化
static int sensor_hw_init(void)
{
    // 初始化I2C设备
    // 配置传感器寄存器
    // ...

    g_sensor.initialized = true;
    return 0;
}

// 自动初始化函数
static int df_sensor_auto_init(void)
{
    int ret = sensor_hw_init();
    if (ret == 0) {
        LOG_I("SENSOR", "Sensor initialized successfully\n");
    } else {
        LOG_E("SENSOR", "Sensor initialization failed: %d\n", ret);
    }
    return ret;
}

// 注册到DEVICE级别（因为依赖I2C框架，I2C在DEVICE级别）
DF_INIT_EXPORT(df_sensor_auto_init, DF_INIT_LEVEL_DEVICE);

// 传感器API实现
int sensor_read_data(uint8_t *data, size_t len)
{
    if (!g_sensor.initialized) {
        LOG_E("SENSOR", "Sensor not initialized\n");
        return -1;
    }

    // 读取传感器数据
    // ...

    return 0;
}
```

## 总结

通过分散自动初始化机制，框架的各个模块可以独立管理自己的初始化逻辑，减少了模块间的耦合，使代码更加清晰和易于维护。开发者只需要在新模块中定义初始化函数并注册到合适的级别，框架会自动按正确的顺序执行所有初始化操作。
