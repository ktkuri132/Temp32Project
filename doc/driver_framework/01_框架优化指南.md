/**
 * @file 驱动框架优化说明和使用示例
 * @date 2026-01-01
 */

# 驱动框架优化完成

## ✅ 已完成的优化

### 1. 统一错误码系统 (dev_frame.h)
```c
typedef enum {
  DEV_OK = 0,              // 操作成功
  DEV_ERR_PARAM = -1,      // 参数错误
  DEV_ERR_NOT_FOUND = -2,  // 设备未找到
  DEV_ERR_TIMEOUT = -3,    // 超时
  DEV_ERR_BUSY = -4,       // 设备忙
  DEV_ERR_NO_MEM = -5,     // 内存不足
  DEV_ERR_HW_FAIL = -6,    // 硬件故障
  DEV_ERR_NOT_INIT = -7,   // 未初始化
  DEV_ERR_ALREADY = -8,    // 已经执行过
  DEV_ERR_NOT_SUPPORT = -9 // 不支持的操作
} dev_err_t;
```

### 2. 设备状态枚举 (dev_frame.h)
```c
typedef enum {
  DEV_STATE_UNINITIALIZED = 0, // 未初始化
  DEV_STATE_INITIALIZED = 1,   // 已初始化
  DEV_STATE_ENABLED = 2,       // 已启用
  DEV_STATE_DISABLED = 3,      // 已禁用
  DEV_STATE_ERROR = -1,        // 错误状态
  DEV_STATE_BUSY = 4           // 忙碌状态
} dev_state_t;
```

### 3. 扩展的设备结构体
```c
typedef struct Dev_Model_Core_TypeDef {
  int index;                    // 设备索引
  char name[20];                // 设备名称
  dev_state_t status;           // 设备状态（使用枚举）
  dev_arg_t arg;                // 设备参数
  uint8_t ref_count;            // 引用计数
  void *priv_data;              // 私有数据指针

  // 基础操作接口
  int (*init)(dev_arg_t);       // 初始化函数指针
  int (*deinit)(dev_arg_t);     // 反初始化函数指针
  int (*open)(dev_arg_t);       // 打开设备
  int (*close)(dev_arg_t);      // 关闭设备
  int (*enable)(dev_arg_t);     // 启动函数指针
  int (*disable)(dev_arg_t);    // 停止函数指针
  int (*ioctl)(int cmd, dev_arg_t); // 控制命令接口
} dev_info_t;
```

### 4. 统一日志系统 (df_log.h)
```c
// 日志级别
LOG_LEVEL_ERROR, LOG_LEVEL_WARN, LOG_LEVEL_INFO,
LOG_LEVEL_DEBUG, LOG_LEVEL_VERBOSE

// 使用方法
LOG_E("TAG", "Error message: %d\n", error_code);
LOG_W("TAG", "Warning message\n");
LOG_I("TAG", "Info message\n");
LOG_D("TAG", "Debug message\n");

// 或者使用默认标签
LOGE("Error: %s\n", Device_Get_Error_String(err));
LOGI("Device initialized\n");
```

### 5. 清理重复定义
- ✅ df_led.h - 删除了重复的dev_arg_t定义
- ✅ df_gpio.h - 删除了重复的dev_arg_t定义
- 所有文件统一使用 dev_frame.h 中的定义

## 📖 使用示例

### 示例1: 设备注册和查找
```c
#include "dev_frame.h"
#include "df_log.h"

// 定义设备初始化函数
int led_init(dev_arg_t arg) {
    // 初始化LED硬件
    return DEV_OK;
}

int led_open(dev_arg_t arg) {
    // 打开LED设备
    return DEV_OK;
}

int led_ioctl(int cmd, dev_arg_t arg) {
    switch(cmd) {
        case DEV_CTRL_CUSTOM + 1: // LED_SET_BRIGHTNESS
            // 设置亮度
            return DEV_OK;
        default:
            return DEV_ERR_NOT_SUPPORT;
    }
}

// 设备信息数组
dev_info_t device_list[] = {
    {
        .name = "led0",
        .init = led_init,
        .open = led_open,
        .ioctl = led_ioctl,
        .arg = arg_null
    },
    DEV_INFO_END  // 结束标志
};

int main(void) {
    // 初始化日志系统
    log_init(LOG_LEVEL_INFO);

    // 注册所有设备
    int ret = Device_Registration(device_list);
    if (ret != DEV_OK) {
        LOGE("Device registration failed: %s\n",
             Device_Get_Error_String(ret));
        return -1;
    }

    // 查找设备
    dev_info_t *led_dev = NULL;
    ret = Find_Device(device_list, "led0", &led_dev);
    if (ret != DEV_OK) {
        LOGE("Cannot find LED device\n");
        return -1;
    }

    // 打开设备
    ret = Device_Open(led_dev);
    if (ret != DEV_OK) {
        LOGE("Cannot open LED device: %s\n",
             Device_Get_Error_String(ret));
        return -1;
    }

    // 使用设备
    Device_Ioctl(led_dev, DEV_CTRL_CUSTOM + 1, arg_u32(50));

    // 关闭设备
    Device_Close(led_dev);

    return 0;
}
```

### 示例2: 日志系统使用
```c
#include "df_log.h"

void test_function(void) {
    uint8_t data[] = {0x01, 0x02, 0x03, 0x04};

    // 不同级别的日志
    LOG_E("TEST", "This is an error\n");
    LOG_W("TEST", "This is a warning\n");
    LOG_I("TEST", "This is info\n");
    LOG_D("TEST", "This is debug\n");

    // 十六进制数据打印
    LOG_HEX_I("TEST", data, sizeof(data));

    // 使用默认标签
    LOGI("Simple log message\n");
    LOGE("Error code: %d\n", -1);
}
```

### 示例3: 引用计数管理
```c
void multi_user_device_example(void) {
    dev_info_t *sensor_dev = NULL;

    // 用户1打开设备
    Find_Device(device_list, "sensor0", &sensor_dev);
    Device_Open(sensor_dev);  // ref_count = 1

    // 用户2也打开设备
    Device_Open(sensor_dev);  // ref_count = 2

    // 用户1关闭
    Device_Close(sensor_dev); // ref_count = 1，设备仍然打开

    // 用户2关闭
    Device_Close(sensor_dev); // ref_count = 0，设备真正关闭
}
```

## 🔧 迁移指南

### 从旧代码迁移

**旧代码：**
```c
if (!device->init(arg)) {
    device->status = 1;  // 成功
} else {
    device->status = -1; // 失败
}
```

**新代码：**
```c
int ret = device->init(arg);
if (ret == DEV_OK) {
    device->status = DEV_STATE_INITIALIZED;
    LOGI("Device initialized\n");
} else {
    device->status = DEV_STATE_ERROR;
    LOGE("Init failed: %s\n", Device_Get_Error_String(ret));
}
```

## 📋 后续建议

### 中优先级（逐步完善）
1. 改进I2C抽象层（统一软件/硬件I2C接口）
2. 中断管理改用链表
3. 添加设备树/设备枚举机制

### 低优先级（功能增强）
1. 电源管理接口（suspend/resume）
2. 单元测试框架
3. 设备热插拔支持
4. DMA支持接口

## 🎯 编译说明

新增文件需要加入编译：
- df_log.c
- df_log.h

确保在CMakeLists.txt或Makefile中包含这些文件。

## 📝 注意事项

1. **日志输出**：默认使用printf，可通过log_set_output()自定义
2. **日志级别**：生产环境建议设为LOG_LEVEL_WARN或ERROR
3. **引用计数**：多线程环境需要加锁保护
4. **错误处理**：所有设备操作函数都应该返回dev_err_t类型
5. **私有数据**：priv_data用于存储设备特定的私有数据
