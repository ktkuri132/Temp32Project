# 构建系统模块化重构说明

## 概述

本次重构将构建系统重组为模块化架构，主要目标：

1. **芯片检测独立化** - 将芯片识别功能提取为独立模块
2. **BSP层独立管理** - BSP目录有独立的CMakeLists.txt管理芯片平台
3. **Device层独立管理** - Device目录有独立的CMakeLists.txt管理外设驱动
4. **构建逻辑优化** - 简化build.py，使用模块化组件

## 目录结构

```
32_temp_project/
├── tool/
│   ├── chip_detector.py        # 新增：芯片检测模块
│   ├── build.py                # 更新：使用chip_detector
│   ├── cmake_generator.py      # 更新：生成模块化CMakeLists
│   ├── source_scanner.py       # 保持：源码扫描
│   └── ...
├── BSP/
│   ├── CMakeLists.txt          # 新增：BSP层独立构建
│   ├── stm32f1/
│   ├── stm32f4/
│   └── CMSIS/
├── Device/
│   ├── CMakeLists.txt          # 新增：Device层独立构建
│   ├── bmp280/
│   ├── mpu6050/
│   └── ...
├── CMakeLists.txt              # 更新：引用BSP和Device子目录
└── ...
```

## 1. chip_detector.py - 芯片检测模块

### 功能职责

集中管理所有与芯片相关的检测和配置逻辑：

- 从BSP目录结构检测芯片型号
- 从宏定义检测芯片型号
- 芯片型号到架构的映射
- FPU配置信息
- OpenOCD下载目标映射

### 主要接口

```python
from chip_detector import ChipDetector

detector = ChipDetector(project_root)

# 获取完整芯片信息
chip_info = detector.get_chip_info()
# 返回: {
#     'chip': 'STM32F407VE',
#     'arch': 'cortex-m4',
#     'fpu': 'fpv4-sp-d16',
#     'float_abi': 'hard',
#     'download_target': 'stm32f4x',
#     'bsp_dir': 'stm32f4'
# }

# 单独获取信息
chip = detector.detect_chip()
arch = detector.detect_chip_arch('STM32F407VE')
download_target = detector.get_download_target('STM32F407VE')
```

### 芯片架构映射

支持的STM32系列：

| 系列 | 架构 | FPU |
|------|------|-----|
| STM32F0, STM32L0, STM32G0 | cortex-m0 | 无 |
| STM32F1, STM32L1 | cortex-m3 | 无 |
| STM32F2, STM32L2 | cortex-m3 | 无 |
| STM32F3 | cortex-m4 | fpv4-sp-d16 |
| STM32F4, STM32F7 | cortex-m4 | fpv4-sp-d16 |
| STM32G4, STM32L4, STM32L5 | cortex-m4 | fpv4-sp-d16 |
| STM32H7 | cortex-m7 | fpv5-d16 |
| STM32U5 | cortex-m33 | fpv5-sp-d16 |

## 2. BSP/CMakeLists.txt - BSP层独立构建

### 功能职责

管理板级支持包（Board Support Package）的编译：

- 接收芯片目录参数 `BSP_CHIP_DIR`
- 递归扫描BSP目录下的所有源文件（.c/.s）
- 收集头文件目录
- 导出 `BSP_SOURCES` 和 `BSP_INCLUDE_DIRS` 到父作用域

### 使用方式

根CMakeLists.txt中调用：

```cmake
# 设置BSP芯片目录
set(BSP_CHIP_DIR "stm32f4")

# 包含BSP子目录
add_subdirectory(BSP)

# 使用BSP导出的变量
include_directories(${BSP_INCLUDE_DIRS})
add_executable(${PROJECT_NAME}.elf ${BSP_SOURCES} ...)
```

### 目录扫描规则

自动包含以下BSP文件：

- `BSP/${BSP_CHIP_DIR}/**/*.c` - 芯片特定驱动
- `BSP/${BSP_CHIP_DIR}/**/*.s` - 启动文件
- `BSP/CMSIS/Core/Include/**` - CMSIS头文件

### 独立编译选项

可以单独编译BSP层用于测试：

```bash
cd build
cmake .. -DBUILD_BSP_ONLY=ON
ninja
```

## 3. Device/CMakeLists.txt - Device层独立构建

### 功能职责

管理外部设备驱动的编译：

- 自动扫描Device目录下的所有子目录
- 为每个设备收集源文件（过滤examples/tests）
- 收集头文件目录
- 导出 `DEVICE_SOURCES` 和 `DEVICE_INCLUDE_DIRS` 到父作用域

### 使用方式

根CMakeLists.txt中调用：

```cmake
# 包含Device子目录
add_subdirectory(Device)

# 使用Device导出的变量
include_directories(${DEVICE_INCLUDE_DIRS})
add_executable(${PROJECT_NAME}.elf ${DEVICE_SOURCES} ...)
```

### 支持的设备

当前支持的外设驱动：

- **传感器**: bmp280 (气压), hmc588 (磁力计), mpu6050 (IMU)
- **显示屏**: sh1106 (OLED), ssd1306 (OLED), st7789 (TFT LCD)

### 文件扫描规则

对于每个设备目录，自动包含：

- `Device/{device}/*.c` - 驱动实现
- `Device/{device}/*.h` - 驱动接口

过滤规则：

- 排除 `examples/` 目录
- 排除 `tests/` 目录

### 独立编译选项

**仅编译Device层:**

```bash
cd build
cmake .. -DBUILD_DEVICE_ONLY=ON
ninja
```

**为每个设备创建独立库:**

```bash
cd build
cmake .. -DBUILD_DEVICE_SEPARATELY=ON
ninja
# 生成: libbmp280.a, libmpu6050.a, libsh1106.a等
```

## 4. cmake_generator.py - 模块化CMakeLists生成

### 主要更新

1. **导入芯片检测器**
   ```python
   from chip_detector import ChipDetector
   detector = ChipDetector(self.project_root)
   chip_info = detector.get_chip_info()
   ```

2. **设置BSP目录**
   ```cmake
   set(BSP_CHIP_DIR "stm32f4")
   ```

3. **添加子目录**
   ```cmake
   add_subdirectory(BSP)
   add_subdirectory(Device)
   ```

4. **使用导出的变量**
   ```cmake
   include_directories(${BSP_INCLUDE_DIRS})
   include_directories(${DEVICE_INCLUDE_DIRS})

   add_executable(${PROJECT_NAME}.elf
       ${SOURCE_FILES}
       ${BSP_SOURCES}
       ${DEVICE_SOURCES}
   )
   ```

## 5. build.py - 构建脚本优化

### 主要更新

1. **导入芯片检测器**
   ```python
   from chip_detector import ChipDetector

   self.chip_detector = ChipDetector(project_root)
   ```

2. **使用芯片信息**
   ```python
   chip_info = self.chip_detector.get_chip_info()
   arch = chip_info.get('arch')
   download_target = chip_info.get('download_target')
   ```

3. **删除重复代码**
   - 删除 `get_download_target()` 方法（移至chip_detector）
   - 删除内联芯片检测逻辑（使用chip_detector）

## 优势

### 1. 关注点分离

- **chip_detector.py** - 专注芯片相关逻辑
- **BSP/CMakeLists.txt** - 专注芯片平台管理
- **Device/CMakeLists.txt** - 专注设备驱动管理
- **build.py** - 专注构建流程编排

### 2. 可维护性

- 添加新芯片：只需修改chip_detector.py的映射表
- 添加新设备：只需在Device/下创建目录，自动检测
- 更换芯片平台：修改BSP_CHIP_DIR即可

### 3. 可测试性

- 每个模块可独立测试
- BSP和Device可独立编译
- 芯片检测逻辑集中，易于单元测试

### 4. 可扩展性

- 支持多芯片平台项目
- 支持多设备驱动库
- 支持第三方BSP和设备驱动

## 使用流程

### 完整构建

```bash
# 1. 运行构建脚本
python tool/build.py

# 2. 进入构建目录
cd build

# 3. 运行CMake和Ninja（如果CMake在PATH中）
cmake -G Ninja ..
ninja
```

### 更换芯片平台

假设从STM32F4切换到STM32F1：

1. 编辑 `tool/project_config.json`：
   ```json
   {
     "project": {
       "chip": "STM32F103C8"
     }
   }
   ```

2. 重新运行构建脚本：
   ```bash
   python tool/build.py
   # 选择 'y' 重新扫描
   ```

3. chip_detector自动检测：
   - arch: cortex-m3
   - bsp_dir: stm32f1
   - download_target: stm32f1x

4. 编译：
   ```bash
   cd build
   ninja
   ```

### 添加新设备驱动

1. 在Device/下创建新目录：
   ```bash
   mkdir Device/new_sensor
   ```

2. 添加驱动文件：
   ```
   Device/new_sensor/
   ├── new_sensor.c
   └── new_sensor.h
   ```

3. 重新运行构建脚本：
   ```bash
   python tool/build.py
   # 自动检测到新设备
   ```

4. Device/CMakeLists.txt自动包含新设备源文件

## 兼容性说明

### 向后兼容

- 保持project_config.json格式不变
- 保持构建命令不变（python tool/build.py）
- 生成的二进制文件完全相同

### 迁移指南

如果从旧版本升级：

1. 无需手动修改任何配置
2. 删除build目录：`rm -rf build`
3. 重新运行：`python tool/build.py`
4. 系统自动使用新的模块化架构

## 故障排查

### BSP_SOURCES为空

**症状**: 编译时提示BSP源文件缺失

**原因**: BSP_CHIP_DIR设置不正确

**解决**:
```bash
# 检查project_config.json中的芯片型号
# 确保BSP目录存在对应的芯片子目录
ls BSP/
```

### DEVICE_SOURCES为空

**症状**: 设备驱动函数未定义

**原因**: Device目录下没有.c文件或被过滤

**解决**:
```bash
# 检查Device目录结构
ls Device/*/

# 确保驱动文件不在examples/或tests/目录中
```

### 芯片架构检测错误

**症状**: FPU配置不正确

**原因**: chip_detector映射表中没有该芯片

**解决**:
1. 编辑 `tool/chip_detector.py`
2. 在 `chip_arch_map` 中添加新芯片映射
3. 重新运行构建脚本

## 总结

通过本次模块化重构，构建系统具备了：

✅ **清晰的职责划分** - 每个模块职责单一明确
✅ **灵活的扩展能力** - 轻松添加新芯片和设备
✅ **独立的编译能力** - BSP和Device可单独编译测试
✅ **集中的配置管理** - 芯片信息统一在chip_detector中
✅ **自动化的文件扫描** - 减少手动配置工作

这为未来支持更多芯片平台和设备驱动奠定了坚实基础。

---

**最后更新**: 2025-01-02
**作者**: 构建系统开发团队
