# 模块化构建系统快速使用指南

## 快速开始

### 1. 基本构建流程

```bash
# 步骤1: 运行构建脚本生成CMakeLists.txt
python tool/build.py

# 步骤2: 进入构建目录并编译（假设CMake和Ninja在PATH中）
cd build
cmake -G Ninja ..
ninja
```

### 2. 首次运行

首次运行时，系统会自动检测：

```bash
$ python tool/build.py

=== 初次运行，自动检测配置 ===
检测到芯片: STM32F407VE
检测到架构: cortex-m4
检测到BSP目录: stm32f4
扫描到40个源文件
扫描到25个头文件目录
已生成: CMakeLists.txt
```

### 3. 后续运行

配置文件存在时，直接使用现有配置：

```bash
$ python tool/build.py

是否重新扫描项目文件? (y/N): N
=== 使用现有配置文件 ===
从配置读取: 40 个源文件
...
已生成: CMakeLists.txt
```

## 三层架构

### 应用层（App Layer）

位于项目根目录，包含：

- `app/` - 应用程序代码
- `Control/` - 控制算法（PID、滤波器）
- `Driver_Framework/` - 驱动框架
- `Middleware/` - 中间件（Shell、通信）

**管理方式**: 根CMakeLists.txt中SOURCE_FILES变量

### BSP层（Board Support Package）

位于 `BSP/` 目录，包含：

- `BSP/stm32f1/` - STM32F1系列支持
- `BSP/stm32f4/` - STM32F4系列支持
- `BSP/CMSIS/` - ARM CMSIS标准

**管理方式**: BSP/CMakeLists.txt独立管理

**生成变量**:
- `BSP_SOURCES` - BSP源文件列表
- `BSP_INCLUDE_DIRS` - BSP头文件目录

### Device层（Device Drivers）

位于 `Device/` 目录，包含：

- `Device/bmp280/` - BMP280气压传感器
- `Device/mpu6050/` - MPU6050 IMU
- `Device/sh1106/` - SH1106 OLED显示屏
- 等等...

**管理方式**: Device/CMakeLists.txt独立管理

**生成变量**:
- `DEVICE_SOURCES` - Device源文件列表
- `DEVICE_INCLUDE_DIRS` - Device头文件目录

## 常用操作

### 更换芯片平台

**场景**: 从STM32F407切换到STM32F103

```bash
# 方法1: 修改配置文件
vim tool/project_config.json
# 修改 "chip": "STM32F103C8"

# 方法2: 删除配置文件重新检测
rm tool/project_config.json
python tool/build.py

# 重新生成构建文件
cd build
rm -rf *
cmake -G Ninja ..
ninja
```

### 添加新的外设驱动

**场景**: 添加DHT22温湿度传感器驱动

```bash
# 步骤1: 创建驱动目录
mkdir Device/dht22

# 步骤2: 添加驱动代码
cat > Device/dht22/dht22.c << 'EOF'
#include "dht22.h"

void dht22_init(void) {
    // 初始化代码
}
EOF

cat > Device/dht22/dht22.h << 'EOF'
#ifndef __DHT22_H__
#define __DHT22_H__

void dht22_init(void);

#endif
EOF

# 步骤3: 重新扫描（选择y）
python tool/build.py
# 是否重新扫描项目文件? (y/N): y

# 步骤4: 编译
cd build
ninja
```

### 独立编译BSP层

**场景**: 只测试BSP层编译是否正确

```bash
cd build
cmake -G Ninja .. -DBUILD_BSP_ONLY=ON
ninja

# 输出: 生成BSP相关的.o文件
```

### 独立编译Device层

**场景**: 只测试Device驱动编译是否正确

```bash
cd build
cmake -G Ninja .. -DBUILD_DEVICE_ONLY=ON
ninja

# 输出: 生成Device相关的.o文件
```

### 为每个设备生成独立库

**场景**: 需要选择性链接某些驱动

```bash
cd build
cmake -G Ninja .. -DBUILD_DEVICE_SEPARATELY=ON
ninja

# 输出:
# libbmp280.a
# libmpu6050.a
# libsh1106.a
# ...
```

## 配置文件说明

### project_config.json 核心字段

```json
{
  "project": {
    "name": "32_temp_project",       // 项目名称
    "chip": "STM32F407VE",            // 芯片型号
    "board": "BLUEPILL",              // 开发板名称
    "architecture": "cortex-m4"       // CPU架构
  },

  "toolchain": {
    "c_compiler": "arm-none-eabi-gcc",
    "cxx_compiler": "arm-none-eabi-g++",
    ...
  },

  "linker": {
    "script": "BSP/stm32f4/CORE/stm32f4xx.ld",
    "additional_scripts": [
      "Driver_Framework/linker/df_init_sections.ld"  // 分散加载脚本
    ],
    "specs": ["nosys.specs", "nano.specs"]
  },

  "build": {
    "optimization": "O0",    // 优化级别: O0/O1/O2/O3/Os
    "debug_info": "g3",      // 调试信息: g0/g1/g2/g3
    "warnings": true,        // 启用警告
    "wall": false,           // -Wall
    "werror": false          // -Werror
  }
}
```

### 修改优化级别

```bash
# 编辑配置文件
vim tool/project_config.json

# 修改 "optimization": "O2"

# 重新生成
python tool/build.py
cd build
ninja
```

### 添加宏定义

```json
{
  "defines": [
    "STM32F40_41xxx",
    "USE_STDPERIPH_DRIVER",
    "DEBUG_ENABLED"           // 新增宏定义
  ]
}
```

## 芯片支持列表

| 芯片系列 | 架构 | FPU | BSP目录 | 下载目标 |
|---------|------|-----|---------|---------|
| STM32F0xx | cortex-m0 | 无 | stm32f0 | stm32f0x |
| STM32F1xx | cortex-m3 | 无 | stm32f1 | stm32f1x |
| STM32F2xx | cortex-m3 | 无 | stm32f2 | stm32f2x |
| STM32F3xx | cortex-m4 | fpv4-sp-d16 | stm32f3 | stm32f3x |
| STM32F4xx | cortex-m4 | fpv4-sp-d16 | stm32f4 | stm32f4x |
| STM32F7xx | cortex-m7 | fpv5-d16 | stm32f7 | stm32f7x |
| STM32H7xx | cortex-m7 | fpv5-d16 | stm32h7 | stm32h7x |
| STM32G0xx | cortex-m0plus | 无 | stm32g0 | stm32g0x |
| STM32G4xx | cortex-m4 | fpv4-sp-d16 | stm32g4 | stm32g4x |
| STM32L0xx | cortex-m0plus | 无 | stm32l0 | stm32l0x |
| STM32L1xx | cortex-m3 | 无 | stm32l1 | stm32l1x |
| STM32L4xx | cortex-m4 | fpv4-sp-d16 | stm32l4 | stm32l4x |
| STM32L5xx | cortex-m33 | fpv5-sp-d16 | stm32l5 | stm32l5x |
| STM32U5xx | cortex-m33 | fpv5-sp-d16 | stm32u5 | stm32u5x |
| STM32WBxx | cortex-m4 | fpv4-sp-d16 | stm32wb | stm32wbx |
| STM32WLxx | cortex-m4 | fpv4-sp-d16 | stm32wl | stm32wlx |

## 当前支持的外设驱动

### 传感器

- **bmp280** - BMP280气压温度传感器（I2C）
- **hmc588** - HMC588三轴磁力计（I2C）
- **mpu6050** - MPU6050六轴IMU（I2C）

### 显示屏

- **sh1106** - SH1106 OLED显示屏 128x64（I2C）
- **ssd1306** - SSD1306 OLED显示屏 128x64（I2C）
- **st7789** - ST7789 TFT LCD彩屏（SPI）

## 故障排查

### 问题1: 编译时找不到头文件

**错误信息**: `fatal error: xxx.h: No such file or directory`

**解决方法**:

```bash
# 重新扫描项目
python tool/build.py
# 选择 y 重新扫描

# 检查生成的CMakeLists.txt中的include_directories
grep "include_directories" CMakeLists.txt
```

### 问题2: BSP_SOURCES为空

**错误信息**: `No source files for target`

**原因**: BSP_CHIP_DIR设置不正确

**解决方法**:

```bash
# 检查BSP目录
ls BSP/

# 检查project_config.json中的chip字段
# 确保chip_detector可以正确识别

# 手动指定BSP目录（编辑CMakeLists.txt）
set(BSP_CHIP_DIR "stm32f4")
```

### 问题3: 链接时符号未定义

**错误信息**: `undefined reference to 'xxx'`

**原因**: 可能是某个驱动的.c文件没有被包含

**解决方法**:

```bash
# 方法1: 重新扫描
python tool/build.py
# 选择 y

# 方法2: 检查Device/CMakeLists.txt
# 确保驱动目录包含.c文件且不在examples/tests/中

# 方法3: 手动添加源文件（编辑根CMakeLists.txt）
set(MY_SOURCES
    path/to/missing.c
)
add_executable(${PROJECT_NAME}.elf ${MY_SOURCES} ...)
```

### 问题4: CMake不在PATH中

**错误信息**: `cmake: command not found`

**解决方法**:

```bash
# Windows (PowerShell)
$env:PATH += ";C:\Program Files\CMake\bin"

# 或使用绝对路径
& "C:\Program Files\CMake\bin\cmake.exe" -G Ninja ..

# Linux/macOS
export PATH=$PATH:/usr/local/bin
```

## 高级用法

### 自定义BSP源文件

如果需要排除某些BSP文件，编辑 `BSP/CMakeLists.txt`:

```cmake
# 收集BSP源文件
file(GLOB_RECURSE BSP_SOURCES
    ${BSP_CHIP_DIR}/*.c
    ${BSP_CHIP_DIR}/*.s
)

# 排除某些文件
list(FILTER BSP_SOURCES EXCLUDE REGEX ".*_template\\.c$")
list(FILTER BSP_SOURCES EXCLUDE REGEX ".*/backup/.*")
```

### 自定义Device源文件

如果需要添加设备初始化代码，编辑 `Device/CMakeLists.txt`:

```cmake
# 在所有设备之前添加共享代码
set(DEVICE_SHARED_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/config.c
    ${CMAKE_CURRENT_SOURCE_DIR}/device_manager.c
)

# 导出时包含共享代码
set(DEVICE_SOURCES ${DEVICE_SHARED_SOURCES} ${DEVICE_SOURCES} PARENT_SCOPE)
```

### 条件编译设备

根据配置选择性编译设备：

```cmake
# Device/CMakeLists.txt

# 只编译指定的设备
set(ENABLED_DEVICES "bmp280;mpu6050;sh1106" CACHE STRING "Enabled devices")

foreach(device ${DEVICE_DIRS})
    get_filename_component(device_name ${device} NAME)

    # 检查是否在启用列表中
    if(device_name IN_LIST ENABLED_DEVICES)
        # 收集源文件...
    endif()
endforeach()
```

使用：

```bash
cd build
cmake -G Ninja .. -DENABLED_DEVICES="bmp280;mpu6050"
ninja
```

## 参考资料

- [构建系统概述](01_构建系统概述.md)
- [模块结构说明](02_模块结构说明.md)
- [重构总结](03_重构总结.md)
- [模块化重构说明](04_模块化重构说明.md)
- [分散自动初始化说明](../driver_framework/03_分散自动初始化说明.md)

---

**最后更新**: 2025-01-02
**提示**: 如遇到问题，请先尝试删除build目录并重新生成
